---
title: "线性表 顺序表示（题）"
date: 2021-04-04T13:57:03+08:00
lastmod: 2021-04-04T13:57:03+08:00
draft: false
keywords: ["线性表",]
description: "顺序表的一些简单题"
tags: ["线性表",]
categories: ["线性表"]
author: "wtnyzhsq"
comment: false
toc: true
autoCollapseToc: false
postMetaInFooter: false
hiddenFromHomePage: false
contentCopyright: false
reward: false
mathjax: false
mathjaxEnableSingleDollar: false
mathjaxEnableAutoNumber: false
hideHeaderAndFooter: false
flowchartDiagrams:
  enable: false
  options: ""
sequenceDiagrams: 
  enable: false
  options: ""

---

 22年王道数据结构中线性表的顺序表的一些简单题的记录。（Golang实现）

<!--more-->

## 1．从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。![image-20210404135906730](https://cdn.jsdelivr.net/gh/wtnyzhsq/cdnstatic/img/20210404135915.png)

```go
/*
思路：
1.编历数组找到最小值对应下标。
2.将数组最后一个元素的值赋值给数组最小值对应下标元素。
*/
//p17 1
type Sqlist struct {
	maxSize int
	length  int
	data    []int
}

func (list Sqlist) p17_1() bool {
    //数组为空显示错误信息推出运行.
    if list.length == 0 {
      fmt.Println("List Empty")
      return false

   }
   flag := list.data[0]
   index := 0
   //编历数组
   for i := 1; i < list.length; i++ {
      if flag > list.data[i] {
         flag = list.data[i]
         index = i
      }
   }
   list.data[index] = list.data[list.length-1]
   list.length--
   return true
}
```

## 2．设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1).

```go
//p17-2
/*
思路：设置一个中间变量编历数组，直接将数组元素第一个值和最后一个值置换。
*/
func (list *Sqlist) p17_2() bool {
	var middle int
	if list.length == 0 {
		fmt.Println("List Empty")
		return false

	}
	for i := 0; i < list.length/2; i++ {
		//注意顺序
		middle = list.data[i]
		list.data[i] = list.data[list.length-i-1]
		list.data[list.length-i-1] = middle

	}
	return true
}
```

## 3、对长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。

```go
//p17-3
/*
最笨本人解法一：🤡🤡🤡
(未达到题目要求，时间空间复杂度都超了)
思路：
1.新建一个切片middle，编历顺序表L记录值为x的数据元素的下标。
2.从最后一个元素开始编历middle，根据元素的值依次从后往前删除。
*/
func (list *Sqlist) p17_3(x int) bool {
   var middle []int
   //记录值为x的元素的下标
   for i := 0; i < list.length; i++ {
      if list.data[i] == x {
         middle = append(middle, i)
      }
   }
   // 编历middle获取需要删除的元素的下标，根据下标从后往前依次删除元素。
   //middle[i]是值为x的顺序表元素的下标
   for i := len(middle) - 1; i >= 0; i++ {
      for j := middle[i]; j < list.length; j++ {
         list.data[j] = list.data[j+1]
      }
   }
   return true
}

/*
两个方法原理方法基本一致
标准解法1：
1.编历顺序表，变量k记录！不等于！x的元素个数。
2.每个不等于x的元素移动到下标为k的位置。
（相当于用不等于x的元素重写顺序表）
*/
func (list *Sqlist) p17_3_2(x int) {
	var k = 0
	for i := 0; i < list.length; i++ {
		if list.data[i] != x {
			list.data[k] = list.data[i]
			k++
		}
	}
	list.length = k
}

/*
标准解法2：
1.编历顺序表，变量k记录！等于！x的元素个数。
2.每个不等于x的元素移动到下标为i-k的位置。
（相当于每个不等于x的元素前移k个位置）
*/
func (list *Sqlist) p17_3_3(x int) {
	var k = 0
	for i := 0; i < list.length; i++ {
		if list.data[i] == x {
			k++
		} else {
			list.data[i-k] = list.data[i]
		}
	}
	list.length = list.length - k
}

```



